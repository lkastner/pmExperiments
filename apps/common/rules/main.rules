user_function toPolynomial($ , $ ){
   my($R, $s) = @_;
   # Initial check for bracket consistency:
   $s =~ s/\s//g;
   index($s, "@") == -1 or die "Forbidden character \"@\" used!";
   my @vars = $R->variables;
   my $stilda = $s;
   foreach my $var (@vars){
      my $varstring = $var."";
      my $replacement = "m".("@" x (length($varstring)-1));
      $varstring = quotemeta($varstring);
      # print "Var: ",$varstring,"\nReplacement: ",$replacement,"\n";
      # print "Before: ",$stilda,"\n";
      $stilda =~ s/$varstring/$replacement/g;
      # print "After: ",$stilda,"\n";
   }
   $stilda =~ m/^[0123456789\/\*\^\-\+@\(\)m]*$/ or die "Input error: ".$stilda.".";
   print "S:  ",$s,"\nST: ",$stilda,"\n";
   return classify($R,$s,$stilda);
}

sub classify{
   my($R,$s,$stilda) = @_;
   print "S:  ",$s,"\nST: ",$stilda,"\n";
   my $isSum = 0;
   my $isProd = 0;
   my $isMonomial = 0;
   my $hasBrackets = index($stilda,"(") > -1;
   # print "Hasbrackets: ",$hasBrackets,"\n";
   if(!$hasBrackets){
      if((index($stilda,"+") > -1) || (index($stilda,"-") > -1)){
         $isSum = 1;
      } else {
         $isMonomial = 1;
      }
   } else {
      my $level = 0;
      my $rest = $stilda;
      my $done = 0;
      while(!$done){
         if($level == 0){
            if($rest =~ m/^[^\(\)]*[\+\-]/){
               $done = 1;
               $isSum = 1;
            } elsif($rest =~ m/^[^\(\)\+\-]*$/) {
               $done = 1;
               $isProd = 1;
            } else {
               if(my($nr) = $rest =~ m/^[^\(\)\+\-]*\((.*)$/){
                  $level++;
                  $rest = $nr;
               } elsif ($rest =~ m/^[^\(\)\+\-]*\)/){
                  die "Too many closing brackets.";
               }
            }
         } else {
            if(my($nr) = $rest =~ m/^[^\(\)]*\)(.*)/){
               $rest = $nr;
               $level--;
            } elsif(my($nr) = $rest =~ m/^[^\(\)]*\((.*)/){
               $rest = $nr;
               $level++;
            } else {
               die "Brackets inconsistent.";
            }
         }
      }
   }
   if($isSum){
      print $s," is a sum.\n";
      return parseSum($R,$s,$stilda,$hasBrackets);
   } elsif($isMonomial){
      print $s," is a monomial.\n";
      return parseMonomial($R,$s,$stilda);
   } elsif($isProd){
      print $s," is a product.\n";
      return parseProd($R,$s,$stilda);
   }
}

sub parseSum{
   my($R,$s,$stilda,$hasBrackets) = @_;
   my $result = new Polynomial($R);
   if($hasBrackets){
      while(length($s)>0){
         my($op) = $stilda =~ m/^([+-]?)/;
         my $pos = length($op);
         my $level = 0;
         my $done = 0;
         while(!$done){
            my $rest = substr($stilda,$pos,length($stilda));
            print "Rest: ",$rest,"\n";
            if($level == 0){
               if(my($tl) = $rest =~ m/^([^\(]*)[\+\-]/){
                  $done = 1;
                  $pos += length($tl);
               } elsif( $rest =~ m/^[^\+\-\(]*\)/){
                  die "Brackets are inconsistent.";
               } elsif ( $rest =~ m/^[^\+\-\(\)]*$/){
                  $done = 1;
                  $pos += length($rest);
               } else {
                  $level++;
                  $pos += index($rest,"(")+1;
               }
            } else {
               if($rest =~ m/^[^\(\)]*\(/){
                  $level++;
                  $pos += index($rest,"(")+1;
               } elsif ($rest =~ m/^[^\(\)]*\)/) {
                  $level--;
                  $pos += index($rest,")")+1;
               } else {
                  die "Brackets are inconsistent.";
               }
            }
         }
         # print substr($s,0,$pos-1);
         if($op eq "+"){
            $result += classify($R, substr($s,1,$pos-1), substr($stilda,1,$pos-1));
            $s = substr($s,$pos,length($s));
            $stilda = substr($stilda,$pos,length($s));
         } elsif($op eq "-") {
            $result -= classify($R, substr($s,1,$pos-1), substr($stilda,1,$pos-1));
            $s = substr($s,$pos,length($s));
            $stilda = substr($stilda,$pos,length($s));
         } else {
            $result += classify($R, substr($s,0,$pos), substr($stilda,0,$pos));
            $s = substr($s,$pos,length($s));
            $stilda = substr($stilda,$pos,length($s));
         }
      }

   } else {
      while(length($s)>0){
         my($op,$monlength) = $stilda =~ m/^([+-]?)([^+-]*)/;
         if($op){
            if($op eq "+"){
               $result += parseMonomial($R,substr($s,1,length($monlength)),$monlength);
            } else {
               $result -= parseMonomial($R,substr($s,1,length($monlength)),$monlength);
            }
         } else {
            $result += parseMonomial($R,substr($s,0,length($monlength)),$monlength);
         }
         my $totallength = length($op) + length($monlength);
         $s = substr($s,$totallength,length($s));
         $stilda = substr($stilda,$totallength,length($stilda));
      }
   }
   return $result;
}

sub parseProd{
   # We can assume that $hasBrackets evaluates to true, since we would have
   # gone into monomial else.
   my($R,$s,$stilda) = @_;
   my $result = new Monomial($R);
   my $level = 0;
   my $pos = 0;
   my $rest = $stilda;
   while(length($s)>0){
      if($level == 0){
         if($pos > 0){
            my $f = substr($s,1,$pos-2);
            my $ftilda = substr($stilda,1,$pos-2);
            my $factor = classify($R,$f,$ftilda);
            my $totallength = $pos;
            $s = substr($s,$totallength,length($s));
            $stilda = substr($stilda,$totallength,length($stilda));
            my($hat,$pow,$star) = $stilda =~ m/^(\^?)(\d*)(\*?)/;
            print "HPS: ",$hat,$pow,$star,"\n";
            if($pow > 0){
               while($pow>0){
                  $result = $factor * $result;
                  $pow--;
               }
            } else {
               $result = $factor * $result;
            }
            $totallength = length($hat.$pow.$star);
            $s = substr($s,$totallength,length($s));
            $stilda = substr($stilda,$totallength,length($stilda));
            $rest = $stilda;
         }
         my($star1,$factor,$star2) = $stilda =~ m/^(\*?)([^\(\)]*[^\*\(\)])(\*?)/;
         if(length($factor)>0){
            $result = classify($R,substr($s,0,length($factor)),substr($stilda,0,length($factor))) * $result;
            my $totallength = length($star1.$factor.$star2);
            $s = substr($s,$totallength,length($s));
            $stilda = substr($stilda,$totallength,length($stilda));
            $rest = $stilda;
         }
         if($stilda =~ m/^\(/){
            $pos = 1;
            $rest = substr($stilda,$pos,length($stilda));
            $level++;
         }
      } else {
         if($rest =~ m/^[^\(\)]*\(/){
            $level++;
            $pos += index($rest,"(")+1;
            $rest = substr($stilda,$pos,length($stilda));
         } elsif ($rest =~ m/^[^\(\)]*\)/) {
            $level--;
            $pos += index($rest,")")+1;
            $rest = substr($stilda,$pos,length($stilda));
         } else {
            die "Brackets are inconsistent. $rest";
         }
      }
   }
   return $result;
}

sub parseMonomial{
   my($R,$s,$stilda) = @_;
   # Sanity check:
   ($s !~ m/^\*(.*)/) or die "Incorrect monomial form.";
   ($s !~ m/(.*)\*$/) or die "Incorrect monomial form.";
   if( $stilda !~ m/m/){
      if(index($stilda,"/")>-1){
         my($a,$b) = $stilda =~ m/^(\d*)\/(\d*)/;
         # print $a," ",$b,"\n";
         return new Rational($a,$b);
      } else {
         return $stilda;
      }
      
   }
   my %varMap = ();
   my @var = $R->variables;
   my $i = 0;
   foreach my $v (@var){
      my $varstring = $v."";
      $varMap{$varstring} = $i;
      $i++;
   }
   my $exp = new Vector<Int>($R->n_vars);
   my $totalcoef = 1;
   while(length($s)>0){
      my($coef,$star1,$varlength,$hat,$pow,$star2) = $stilda =~ m/^(\d*\/?\d*)(\*?)(m@*)(\^?)(\d*)(\*?)/;
      # print $coef,$star1,$varlength,$hat,$pow,$star2,"\n";
      my $varstring = substr($s,0,length($varlength));
      if($pow){
         $exp->[$varMap{$varstring}] += $pow;
      } else {
         $exp->[$varMap{$varstring}] ++;
      }
      my $totallength = length($coef)+length($star1)+length($varlength)+length($hat)+length($pow)+length($star2);
      $s = substr($s,$totallength,length($s));
      $stilda = substr($stilda,$totallength,length($stilda));
      # print "S: ",$s,"\n";
      if($coef){
         if(index($coef,"/")>-1){
            my($a,$b) = $coef =~ m/^(\d*)\/(\d*)/;
            # print $a," ",$b,"\n";
            $totalcoef *= new Rational($a,$b);
         } else {
            $totalcoef *= $coef;
         }
      }
   }
   my $result = new Monomial($exp,$R);
   if($totalcoef != 1){
      return $totalcoef*$result;
   } else {
      return $result;
   }
}
