

# Return a combination of the Hilbert basis elements H that yield
# a given vector v. For containment checking we also need the facets
# F of the cone.
user_function find_positive_combination(Vector, Matrix, Matrix){
   my ($v, $Hilbert_basis, $facets) = @_;
   # Check if v is really contained:
   (minimum($facets*$v)>=0) or die "v is not contained.";
   my $result = new Vector($Hilbert_basis->rows);
   my $zero = new Vector($v->dim);
   while($v != $zero){
      for(my $i = 0; $i<$Hilbert_basis->rows; $i++){
         my $veval = $facets*$v;
         my $heval = $facets*$Hilbert_basis->[$i];
         my $max = maximum($veval);
         # print $veval,"\n",$heval,"\n\n";
         my @quotient = map{
            $heval->[$_]>0 ? floor($veval->[$_]/$heval->[$_]) : $max;
         }@0..($veval->dim-1);
         my $quotient = new Vector(@quotient);
         my $factor = minimum($quotient);
         if($factor>0){
            $v = $v - $factor*$Hilbert_basis->[$i];
            $result->[$i]+=$factor;
         }
      }
   }
   return $result;
}

user_function vector_to_monomial_string(Vector, @ ){
   my($input, @vars) = @_;
   my $num_vars = @vars;
   $num_vars == $input->dim or die "Wrong number of variables.";
   my $result = "1";
   for(my $i=0; $i<$input->dim; $i++){
      if($input->[$i] > 0){
         $result .= "*".$vars[$i]."^".$input->[$i];
      }
   }
   return $result;
}

user_function vector_to_binomial_string(Vector, @ ){
   my($input, @vars) = @_;
   my $positive = new Vector($input->dim);
   my $negative = new Vector($input->dim);
   for(my $i=0; $i<$input->dim; $i++){
      $positive->[$i] = $input->[$i] > 0 ? $input->[$i] : 0;
      $negative->[$i] = $input->[$i] < 0 ? -$input->[$i] : 0;
   }
   return vector_to_monomial_string(new Vector($positive), @vars)."-".vector_to_monomial_string(new Vector($negative), @vars);
}

user_function find_nice_projection(Cone){
   my($C) = @_;
   $C->POINTED or die "This method does only work for pointed cones.";
   if($C->DIM == $C->AMBIENT_DIM){
      return(unit_matrix($C->DIM), unit_matrix($C->DIM));
   } else {
      my @HNF = hermite_normal_form($C->HILBERT_BASIS);
      my $transform = dense($HNF[1]);
      my $projection = unit_matrix($C->DIM) / zero_matrix($C->AMBIENT_DIM-$C->DIM, $C->DIM);
      $projection = $transform * $projection;
      return((new Matrix<Integer>($transform)), (new Matrix<Integer>($projection)));
   }
}

user_function represent_vectors_in_Hilbert_basis(Matrix, Matrix, Matrix){
   my($vectors, $Hilbert_basis, $facets) = @_;
   my @result = map(find_positive_combination($_, $Hilbert_basis, $facets), @$vectors);
   return new Matrix<Integer>(@result);
}

user_function toric_ideal_as_string(Cone, @ ){
   my($cone, @variables) = @_;
   $cone->POINTED or die "This method only works for a pointed cone.";
   my $toric_ideal = $cone->TORIC_IDEAL;
   if($toric_ideal->rows == 0){
      return "0";
   } else {
      my @result = map(vector_to_binomial_string($_, @variables), @$toric_ideal);
      return join(",", @result);
   }
}
