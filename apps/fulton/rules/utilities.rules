
object NormalToricVariety {

   property SINGULAR_TORIC_RING : String;

   property MONOID : Cone;

   rule MONOID : RAYS {
      $this->MONOID = new Cone(INEQUALITIES=>$this->RAYS);
   }
   precondition : AFFINE;

   rule SINGULAR_TORIC_RING : MONOID {
      my $monoid = $this->MONOID;
      my $ringname = get_random_string();
      my @variables = map("x(".$_.")",1..$monoid->HILBERT_BASIS->rows);
      my $toric_ideal = toric_ideal_as_string($monoid, @variables);
      singular_eval("ring R_".$ringname." = 0,(".join(",",@variables)."),dp;");
      singular_eval("ideal toric_ideal = ".$toric_ideal.";");
      singular_eval("qring r_".$ringname." = std(toric_ideal);");
      $this->SINGULAR_TORIC_RING = $ringname;
   }
   precondition : AFFINE;

   object TDivisor {
      
      property SINGULAR_IDEAL : String;

      property MODULE_GENERATORS : Matrix<Integer>;

      property SYZYGIES_MODULE : String;

   }

   rule DIVISOR.MODULE_GENERATORS : DIVISOR.SECTION_POLYTOPE{
      my $section_polytope = $this->DIVISOR->SECTION_POLYTOPE;
      my $result = lower_lattice_points($section_polytope);
      $this->DIVISOR->MODULE_GENERATORS = $result->minor(All, ~[0]);
   }
   precondition : AFFINE;

   rule DIVISOR.SYZYGIES_MODULE : SINGULAR_TORIC_RING, DIVISOR.SINGULAR_IDEAL{
      my $ringname = $this->SINGULAR_TORIC_RING;
      my $idealname = $this->DIVISOR->SINGULAR_IDEAL;
      singular_eval("setring r_".$ringname.";");
      singular_eval("module syz_".$idealname." = syz(div_".$idealname.");");
      $this->DIVISOR->SYZYGIES_MODULE = $idealname;
   }
   precondition : AFFINE;

   rule DIVISOR.SINGULAR_IDEAL : SINGULAR_TORIC_RING, MONOID, DIVISOR.MODULE_GENERATORS{
      my $ringname = $this->SINGULAR_TORIC_RING;
      my $generators = $this->DIVISOR->MODULE_GENERATORS;
      # print "Gens: ",$generators,"\n";
      my $monoid = $this->MONOID;
      my $mod_vector = find_vector_moving_points_inside_cone($generators, $monoid);
      # print "Mod vector: ",$mod_vector,"\n";
      my @variables = map("x(".$_.")",1..$monoid->HILBERT_BASIS->rows);
      my $mod_gens = new Matrix(map($mod_vector + $_, @$generators));
      my $mod_gens_monomial_exponents = represent_vectors_in_Hilbert_basis($mod_gens, $monoid->HILBERT_BASIS, $monoid->FACETS);
      my @mod_gens_monomials = map(vector_to_monomial_string($_,@variables), @$mod_gens_monomial_exponents);
      my $idealname = get_random_string();
      singular_eval("setring r_".$ringname.";");
      singular_eval("ideal div_".$idealname." = ".join(",",@mod_gens_monomials).";");
      singular_eval("div_".$idealname." = std(div_".$idealname.");");
      $this->DIVISOR->SINGULAR_IDEAL = $idealname;
   }
   precondition : AFFINE;

   user_method exti_dimension_singular( $ , TDivisor, TDivisor){
      my $toric_variety = $_[0];
      my $i = $_[1];
      my $divisor1 = $_[2];
      my $divisor2 = $_[3];
      my $ringname = $toric_variety->SINGULAR_TORIC_RING;
      my $syzygies1 = $divisor1->SYZYGIES_MODULE;
      my $syzygies2 = $divisor2->SYZYGIES_MODULE;
      singular_eval("setring r_".$ringname.";");
      load_singular_library("homolog.lib");
      singular_eval("module M = Ext(".$i.", syz_".$syzygies1.", syz_".$syzygies2.");");
      singular_eval("M = std(M);");
      singular_eval("int r = vdim(M);");
      return singular_get_var("r");
   }

}

sub find_vector_moving_points_inside_cone{
   my($points, $cone) = @_;
   $cone->FULL_DIM or die "This method will most likely fail for non fulldimensional cones.";
   my $facets = $cone->FACETS;
   my @non_contained = grep(minimum($facets * $_) < 0, @$points);
   if(my $s = @non_contained == 0){
      return zero_vector($points->cols);
   }
   # print "Have to move inside.\n";
   my @new_facets = map(($facets*$_) | $facets, @$points);
   my $solution_facets = pop @new_facets;
   foreach my $m (@new_facets){
      $solution_facets = $solution_facets / $m;
   }
   # print "New facets:\n",$solution_facets,"\n";
   my $solution_poly = new Polytope(INEQUALITIES=>$solution_facets);
   my $solution_cone = new Cone($solution_poly);
   my @solutions = grep($_->[0] == 1, @{$solution_cone->HILBERT_BASIS});
   return $solutions[0]->slice(1);
}

sub get_random_string{
   my @chars = ("A".."Z", "a".."z");
   my $string;
   $string .= $chars[rand @chars] for 1..8;
   return $string;
}


# Return a combination of the Hilbert basis elements H that yield
# a given vector v. For containment checking we also need the facets
# F of the cone.
user_function find_positive_combination(Vector, Matrix, Matrix){
   my ($v, $Hilbert_basis, $facets) = @_;
   # Check if v is really contained:
   (minimum($facets*$v)>=0) or die "v is not contained: ".$v.".";
   my $result = new Vector($Hilbert_basis->rows);
   my $zero = new Vector($v->dim);
   while($v != $zero){
      for(my $i = 0; $i<$Hilbert_basis->rows; $i++){
         my $veval = $facets*$v;
         my $heval = $facets*$Hilbert_basis->[$i];
         my $max = maximum($veval);
         # print $veval,"\n",$heval,"\n\n";
         my @quotient = map{
            $heval->[$_]>0 ? floor($veval->[$_]/$heval->[$_]) : $max;
         }@0..($veval->dim-1);
         my $quotient = new Vector(@quotient);
         my $factor = minimum($quotient);
         if($factor>0){
            $v = $v - $factor*$Hilbert_basis->[$i];
            $result->[$i]+=$factor;
         }
      }
   }
   return $result;
}

user_function vector_to_monomial_string(Vector, @ ){
   my($input, @vars) = @_;
   my $num_vars = @vars;
   $num_vars == $input->dim or die "Wrong number of variables.";
   my $result = "1";
   for(my $i=0; $i<$input->dim; $i++){
      if($input->[$i] > 0){
         $result .= "*".$vars[$i]."^".$input->[$i];
      }
   }
   return $result;
}

user_function vector_to_binomial_string(Vector, @ ){
   my($input, @vars) = @_;
   my $positive = new Vector($input->dim);
   my $negative = new Vector($input->dim);
   for(my $i=0; $i<$input->dim; $i++){
      $positive->[$i] = $input->[$i] > 0 ? $input->[$i] : 0;
      $negative->[$i] = $input->[$i] < 0 ? -$input->[$i] : 0;
   }
   return vector_to_monomial_string(new Vector($positive), @vars)."-".vector_to_monomial_string(new Vector($negative), @vars);
}

user_function find_nice_projection(Cone){
   my($C) = @_;
   $C->POINTED or die "This method does only work for pointed cones.";
   if($C->DIM == $C->AMBIENT_DIM){
      return(unit_matrix($C->DIM), unit_matrix($C->DIM));
   } else {
      my @HNF = hermite_normal_form($C->HILBERT_BASIS);
      my $transform = dense($HNF[1]);
      my $projection = unit_matrix($C->DIM) / zero_matrix($C->AMBIENT_DIM-$C->DIM, $C->DIM);
      $projection = $transform * $projection;
      return((new Matrix<Integer>($transform)), (new Matrix<Integer>($projection)));
   }
}

user_function represent_vectors_in_Hilbert_basis(Matrix, Matrix, Matrix){
   my($vectors, $Hilbert_basis, $facets) = @_;
   my @result = map(find_positive_combination($_, $Hilbert_basis, $facets), @$vectors);
   return new Matrix<Integer>(@result);
}

user_function toric_ideal_as_string(Cone, @ ){
   my($cone, @variables) = @_;
   $cone->POINTED or die "This method only works for a pointed cone.";
   my $toric_ideal = $cone->TORIC_IDEAL;
   if($toric_ideal->rows == 0){
      return "0";
   } else {
      my @result = map(vector_to_binomial_string($_, @variables), @$toric_ideal);
      return join(",", @result);
   }
}

# Find all lattice points of a polytope P that are not reachable
# from some other lattice point via the tail cone.
user_function lower_lattice_points(Polytope){
   my ($P) = @_;
   my $C = new Cone($P);
   my $H = $C->HILBERT_BASIS_GENERATORS->[0];
   return new Matrix(grep($_->[0]==1,@$H));
}
