object CyclicQuotient {
   
   property CLASS_GROUP_REPRESENTATIVES : Matrix;

   rule CLASS_GROUP_REPRESENTATIVES : N, Q{
      my $n = $this->N;
      my $q = $this->Q;
      my @class_group = map((new Vector(-$_, 0)),1..(new Int($n)));
      $this->CLASS_GROUP_REPRESENTATIVES = new Matrix<Rational>(@class_group);
   }


   declare object ResolutionData;

   object ResolutionData {
      
      property WEIGHTED_EDGES : Map<Pair<Vector, Vector>, Matrix>;

      property LABELS : String;
      
      property GRAPH : Graph<Directed>;

      property INCIDENCE_MATRIX : Matrix;

   }

   property RESOLUTION : ResolutionData;

   property EXT1_MATRIX : Matrix;
   
   property TOR1_MATRIX : Matrix;

   rule TOR1_MATRIX : EXT1_MATRIX, RESOLUTION.INCIDENCE_MATRIX{
      my $ext1 = $this->EXT1_MATRIX;
      my $incidence_matrix = $this->RESOLUTION->INCIDENCE_MATRIX;
      $this->TOR1_MATRIX = $incidence_matrix * $incidence_matrix * $ext1;
   }

   rule EXT1_MATRIX : DUAL_CONTINUED_FRACTION{
      my $dcf = $this->DUAL_CONTINUED_FRACTION;
      $this->EXT1_MATRIX = ext1_mat_from_dcf($dcf);
   }

   rule RESOLUTION.INCIDENCE_MATRIX : N, RESOLUTION.WEIGHTED_EDGES{
      my $n = $this->N;
      my $weighted_edges = $this->RESOLUTION->WEIGHTED_EDGES;
      my $incidence_matrix = new Matrix(new Int($n), new Int($n));
      foreach my $edge (keys %$weighted_edges){
         my $source = $edge->[0];
         my $target = $edge->[1];
         #print $source," ",$target,"\n";
         my $row = -$target->[0]-1;
         my $col = -$source->[0]-1;
         $incidence_matrix->($row, $col) = $weighted_edges->{$edge}->rows;
      }
      $this->RESOLUTION->INCIDENCE_MATRIX = $incidence_matrix;
   }

   rule RESOLUTION.WEIGHTED_EDGES : CLASS_GROUP_REPRESENTATIVES, N, Q {
      my $G = $this->CLASS_GROUP_REPRESENTATIVES;
      my $n = $this->N;
      my $weighted_edges = new Map<Pair<Vector, Vector>, Matrix>();
      foreach my $coefficients (@$G){
         my $divisor = $this->DIVISOR(COEFFICIENTS=>$coefficients, temporary);
         my $generators = sort_matrix_rows_by_first_coordinate($divisor->MODULE_GENERATORS);
         # print $generators,"\n";
         my $target = $coefficients;
         for(my $j = 1; $j<$generators->rows; $j++){
            my $inbetween = $generators->[$j]->[0] - $generators->[$j-1]->[0];
            my $source = new Vector(-$inbetween, 0);
            my $edge = new Pair<Vector,Vector>($source, $target);
            my $shift = $generators->[$j-1];
            if(!defined $weighted_edges->{$edge}){
               $weighted_edges->{$edge} = new Matrix($shift);
            } else {
               my $oldshift = $weighted_edges->{$edge};
               $weighted_edges->{$edge} = $oldshift / $shift;
            }
         }
      }
      $this->RESOLUTION->WEIGHTED_EDGES = $weighted_edges;
   }

   rule RESOLUTION.GRAPH.ADJACENCY, RESOLUTION.GRAPH.NODE_LABELS : CLASS_GROUP_REPRESENTATIVES, N, RESOLUTION.WEIGHTED_EDGES{
      my $class_group = $this->CLASS_GROUP_REPRESENTATIVES;
      my $graph = new common::Graph<Directed>($class_group->rows);
      my $weighted_edges = $this->RESOLUTION->WEIGHTED_EDGES;
      my $numbering = new Map<Vector, Int>();
      my $k = 0;
      foreach my $g (@$class_group){
         $numbering->{$g} = $k;
         $k++;
      }
      foreach my $edge (keys %$weighted_edges){
         my $source = $edge->[0];
         my $target = $edge->[1];
         $graph->edge($numbering->{$source}, $numbering->{$target});
      }
      $this->RESOLUTION->GRAPH->NODE_LABELS = @$class_group;
      $this->RESOLUTION->GRAPH->ADJACENCY = $graph;
   }

}

user_function ext1_mat_from_dcf(Vector<Integer>){
   my($dcf) = @_;
   $dcf = new Vector<Integer>($dcf);
   my $length = $dcf->dim;
   if(($length == 0) || ($dcf == ones_vector<Integer>(1))){
      return zero_matrix(1,1);
   }
   if($dcf->[$length-1] == 1){
      $dcf = $dcf->slice(0, $length-1);
      $dcf->[$dcf->dim - 1]--;
      return ext1_mat_from_dcf(new Vector<Integer>($dcf));
   }
   $dcf->[$length-1]--;
   my @dcf = @$dcf;
   my $upper_left_dcf = new Vector<Integer>(@dcf[0..($length-2)]);
   my $lower_right_dcf = new Vector<Integer>(@dcf);
   my $upper_left = ext1_mat_from_dcf($upper_left_dcf);
   my $lower_right = ext1_mat_from_dcf($lower_right_dcf);
   my $A;
   if($upper_left->rows > $lower_right->rows){
      my $start = $upper_left->rows - $lower_right->rows;
      $A = $upper_left->minor(All, [$start..($upper_left->rows-1)]);
   } else {
      my $start = $lower_right->rows - $upper_left->rows;
      $A = $lower_right->minor([$start..($lower_right->rows-1)], All);
   }
   my $result = ($upper_left | $A) / (transpose($A) | $lower_right);
   $result = $result + upper_triangular_ones_matrix($result->rows);
   return new Matrix($result);
}

sub upper_triangular_ones_matrix{
   my($n) = @_;
   return new Matrix(map(ones_vector($n-$_) | zero_vector($_), 1..$n));
}

user_function ext_mat_test(Vector<Integer>){
   my($c) = @_;
   if($c == new Vector<Integer>([1])){
      return new Matrix([[0]]);
   }
   my($UB, $LB, $UR) = splitted_ext_mat($c);
   my $replacement = ($UB | $UR) / (transpose($UR) | $LB);
   my $triang = new Matrix(map(ones_vector($replacement->cols - 1 - $_)|zero_vector($_), 0..($replacement->cols-2)));
   $triang = zero_vector($replacement->cols) / (zero_vector($triang->rows) | $triang);
   $replacement = $replacement + $triang;
   return $replacement;

}


user_function splitted_ext_mat(Vector<Integer>){
   my($c) = @_;
   if($c == new Vector<Integer>([2])){
      return (new Matrix([[0]]),new Matrix([[0]]),new Matrix([[0]]));
   }
   if($c->[$c->dim - 1] == 2){
      # Replace lower block
      my $ctilda = new Vector<Integer>($c->slice(0, $c->dim - 1));
      my($UB, $LB, $UR) = splitted_ext_mat($ctilda);
      my $replacement = ($UB | $UR) / (transpose($UR) | $LB);
      my $triang = new Matrix(map(ones_vector($replacement->cols - 1 - $_)|zero_vector($_), 0..($replacement->cols-2)));
      $triang = zero_vector($replacement->cols) / (zero_vector($triang->rows) | $triang);
      $replacement = $replacement + $triang;
      $LB = $replacement;
      while($UR->cols < $replacement->cols){
         $UR = $UB | $UR;
      }
      return (new Matrix($UB), new Matrix($LB), new Matrix($UR));
   } else {
      # Replace upper block
      my $ctilda = new Vector<Integer>($c);
      $ctilda->[$ctilda->dim - 1]--;
      my($UB, $LB, $UR) = splitted_ext_mat($ctilda);
      my $replacement = ($UB | $UR) / (transpose($UR) | $LB);
      my $triang = new Matrix(map(ones_vector($replacement->cols - 1 - $_)|zero_vector($_), 0..($replacement->cols-2)));
      $triang = zero_vector($replacement->cols) / (zero_vector($triang->rows) | $triang);
      $replacement = $replacement + $triang;
      $UB = $replacement;
      while($UR->rows < $replacement->rows){
         $UR = $UR / $LB;
      }
      return (new Matrix($UB), new Matrix($LB), new Matrix($UR));
   }
}

sub sort_matrix_rows_by_first_coordinate{
   my($matrix) = @_;
   if($matrix->rows == 1){
      return $matrix;
   }
   my @rows = @$matrix;
   my @sorted_rows = sort{$a->[0] <=> $b->[0]} @rows;
   return new Matrix(@sorted_rows);
}





